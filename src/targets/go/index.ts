import { Target } from "../../target";
import { api10 } from "raml-1-parser";

import * as child from "child_process";
import * as path from "path";
import * as fs from "fs";

/**
 * Uppercases the first character in the string.
 */
function upperFirst(str: string): string {
    return str.slice(0, 1).toUpperCase() + str.slice(1);
}

export class GoTarget implements Target {
    check(): Promise<void> {
        return Promise.resolve();
    }

    /**
     * Returns a gofmt process that writes to a
     * file in the target output directory.
     */
    _startStream(output: string, file: string, cmd: string="gofmt"): child.ChildProcess {
        const fmt = child.spawn(cmd);
        fmt.stderr.pipe(process.stderr);
        fmt.stdout.pipe(fs.createWriteStream(path.join(output, file)));
        fmt.stdin.write("// AUTOGENERATED FILE, DO NOT EDIT\n\npackage client\n\n");

        return fmt;
    }

    /**
     * Returns the Go type for a RAML type declaration.
     */
    _translateType(type: api10.TypeDeclaration): string {
        const getInnerStr = (str: string): string => {
            if (str.endsWith("[]")) {
                return `[]${getInnerStr(str.slice(0, -2))}`;
            }

            if (str.indexOf("|") !== -1) {
                return `interface{}`;
            }

            switch (str) {
            case "string":              return "string";
            case "number":              return "int";
            case "uint":                return "uint";
            case "boolean":             return "bool";
            case "object":              return "map[string]interface{}";
            case "IsoDate":             return "time.Time";
            case "UnixTimestampMillis": return "time.Time";
            }

            return str;
        };

        let out = "";
        if (!type.required()) {
            out += "*";
        }

        let primary = type.type()[0];
        if (primary === "array") {
            out += "[]";
            primary = (<api10.ArrayTypeDeclaration>type).items().type()[0];
        }

        out += getInnerStr(primary);

        return out;
    }

    /**
     * Returns the internal, Go name for a JavaScript property.
     */
    _translatePropName(name: string, isExported: boolean=true): string {
        name = name.split(/[^a-z0-9]+/ig)
            .map((str, i) => (i > 0 || isExported) ? upperFirst(str) : str)
            .join('');

        if (name === "type") {
            name = "kind";
        }

        return name;
    }

    /**
     * Creates a models.go file containing objects from the API.
     */
    _createModels(api: api10.Api, output: string): child.ChildProcess {
        const stream = this._startStream(output, "models.go");

        /**
         * Returns an object containing a map of property names to their
         * Go type declarations, for the given RAML type declaration.
         */
        const generateTypesFor = (type: api10.TypeDeclaration): { [prop:string]: string } => {
            if (!("properties" in type)) {
                return {};
            }

            const objType = <api10.ObjectTypeDeclaration>type;
            const declaration : { [prop:string]: string } = {};
            objType.properties().forEach(prop => {
                const name = this._translatePropName(prop.name());
                const annotation = "`json:\"" + prop.name() + "\"`";
                declaration[name] = `${this._translateType(prop)} ${annotation}`;
            });

            objType.type().forEach(subtype => {
                api.types().some(type => {
                    if (type.name() === subtype) {
                        Object.assign(declaration, generateTypesFor(type));
                        return true;
                    }
                });
            });

            return declaration;
        }

        api.types().forEach(type => {
            if (!("properties" in type)) {
                return;
            }

            stream.stdin.write(`type ${type.name()} struct {`);
            const props = generateTypesFor(type);
            Object.keys(props).forEach(prop => {
                stream.stdin.write(`${prop} ${props[prop]}\n`)
            });
            stream.stdin.write("}\n\n");
        });

        return stream;
    }

    _createEndpoints(api: api10.Api, output: string): child.ChildProcess {
        const stream = this._startStream(output, "endpoints.go", "cat");
        const generateMethods = (resource: api10.Resource) => {
            resource.methods().forEach(method => {
                stream.stdin.write(`func ${method.displayName()}(`);
                resource.uriParameters().forEach((param, i) => {
                    if (i > 0) {
                        stream.stdin.write(", ");
                    }
                    stream.stdin.write(this._translatePropName(param.name(), false));
                    stream.stdin.write(' ' + this._translateType(param));
                });
                stream.stdin.write(") (http.Response, ");

                const goodRes = method.responses().find(res => Number(res.code().value()) < 300);
                if (goodRes && goodRes.body().length > 0) {
                    stream.stdin.write(`${this._translateType(goodRes.body()[0])}, `);
                }

                stream.stdin.write(`error) { /* todo */ }\n`);
            });

            resource.resources().forEach(generateMethods);
        };

        api.resources().forEach(generateMethods);

        return stream;
    }

    generate(api: api10.Api, output: string): Promise<void> {
        const streams = [
            this._createModels(api, output),
            this._createEndpoints(api, output),
        ];

        return new Promise<void>((resolve, reject) => {
            let todo = streams.length;
            const done = () => {
                todo--;
                if (todo === 0) {
                    resolve();
                }
            };

            streams.forEach(stream => {
                stream.stdin.end();
                stream.once("exit", done);
                stream.once("error", reject);
            });
        });
    }
}

export default new GoTarget();