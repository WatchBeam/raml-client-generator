import { Stringable, WriteCollector } from "./util";
import * as child from "child_process";
import * as path from "path";
import * as fs from "fs";

function fmtPipe(target: string, fn: (input: NodeJS.WritableStream) => void): Promise<void> {
    const fmt = child.spawn("gofmt");
    fmt.stderr.pipe(process.stderr);
    fmt.stdout.pipe(fs.createWriteStream(target));
    fn(fmt.stdin);

    return new Promise<void>((resolve, reject) => {
        fmt.once("exit", (status: number) => {
            if (status === 0) {
                resolve();
            } else {
                reject(new GofmtError(`Error formatting file, exit code ${status}`));
            }
        });

        fmt.once("error", (err: any) => {
            reject(err);
        });
    });
}

/**
 * Module is used for building a Go module in a specified target directory.
 */
export class Module {

    private files = new Array<{ save(): Promise<void> }>();
    private identifiers : { [name: string]: any } = {};

    /**
     * Creates a new module writing into the target directory. The module
     * name will be the last segment of the directory path, unless otherwise
     * specified.
     */
    constructor(private dir: string, private name: string=null) {
        if (name === null) {
            this.name = path.basename(dir);
        }
    }

    /**
     * File creates a new file within the module.
     */
    file(name: string): File {
        const f = new File(path.join(this.dir, name), this);
        this.files.push(f)
        return f;
    }

    /**
     * Queues a filed to be copied over into the target directory.
     */
    include(filePath: string) {
        const target = path.join(this.dir, path.basename(filePath));
        const rs = fs.createReadStream(filePath);

        this.files.push({
            save(): Promise<void> {
                return fmtPipe(target, s => rs.pipe(s));
            }
        });
    }

    /**
     * Save signals that you are finished operations on the module and saves
     * out all files.
     */
    save(): Promise<void> {
        return Promise.all(this.files.map(f => f.save()))
        .then(() => {});
    }

    /**
     * Records a new indentifier in the module. This is called when functions,
     * structs, etc. are created in Files.
     */
    addIdentifier(name: string, cls: any) {
        this.identifiers[name] = cls;
    }

    /**
     * Attempts to look up an already-defined identifier in the module.
     * It returns undefined if no such identifier exists.
     */
    getIdentifier(name: string): any {
        return this.identifiers[name];
    }

    /**
     * Returns the name of the module.
     */
    getName(): string {
        return this.name;
    }
}

class GofmtError extends Error {}

/**
 * The file represents a single file within a module.
 */
export class File {

    private content = new WriteCollector();
    private imports = new Imports();

    constructor(private path: string, public module: Module) {
        this.write(`// AUTOGENERATED FILE, DO NOT EDIT\n\npackage ${module.getName()}\n\n`);
        this.content.write(this.imports);
    }

    /**
     * Adds a new import to the file.
     */
    import(name: string): File {
        this.imports.add(name);
        return this;
    }

    /**
     * Creates a new struct appended to this file.
     */
    struct(name: string): Struct {
        const s = new Struct(name);
        this.addAndWrite(name, s);
        return s;
    }

    /**
     * Creates a new func appended to this file.
     */
    func(name: string): Func {
        const s = new Func(name);
        this.addAndWrite(name, s);
        return s;
    }

    private addAndWrite(name: string, s: Stringable) {
        this.module.addIdentifier(name, s);
        this.write(s);
    }

    /**
     * Write appends new content to the file.
     */
    write(data: Stringable): File {
        this.content.write(data);
        return this;
    }

    /**
     * Saves out the file to the filesystem.
     */
    save(): Promise<void> {
        return fmtPipe(this.path, s => {
            s.write(this.content.toString());
            s.end();
        });
    }
}

/**
 * A Struct is a builder class to build struct definitions in Go.
 */
export class Struct implements Stringable {

    private fields : { [field: string]: string } = {};
    private parents : { [name: string]: void } = {};

    constructor(private name: string) {}

    /**
     * Adds a new field to the struct.
     */
    field(name: string, type: string, annotation: string=null): Struct {
        this.fields[name] = type;
        if (annotation) {
            this.fields[name] += " `" + annotation + "`";
        }

        return this;
    }

    /**
     * Returns a list of fields on the struct.
     */
    getFields(): { [field: string]: string } {
        return this.fields
    }

    /**
     * Adds a parent which this struct composes.
     */
    composes(parent: string): Struct {
        this.parents[parent] = undefined;
        return this;
    }

    toString(): string {
        let out = `type ${this.name} struct {\n`;
        Object.keys(this.parents).forEach(parent => {
            out += `\t${parent}\n`;
        });
        Object.keys(this.fields).forEach(name => {
            out += `\t${name} ${this.fields[name]}\n`;
        });
        out += `}\n\n`;

        return out;
    }
}

/**
 * Imports is a builder for the "import" declaration at the top of Go files.
 */
class Imports implements Stringable {

    private imports : { [name: string]: void } = {};

    /**
     * Inserts a new import by its name. It does nothing if the module
     * is already imported.
     */
    add(name: string) {
        this.imports[name] = undefined;
    }

    toString() {
        const stdlib = new Array<String>();
        const external = new Array<String>();

        Object.keys(this.imports).forEach(imp => {
            // Approximate thing to qualify the import as "external" if it
            // has a dot in the first path segment (e.g. github.com)
            if ((/^[^/]+\..+\//).test(imp)) {
                external.push(imp);
            } else {
                stdlib.push(imp);
            }
        });

        const count = stdlib.length + external.length;
        if (count === 0) return "";
        if (count === 1) return `import ${stdlib.concat(external).join()}`;

        let out = stdlib.map(i => `\t"${i}"`).join("\n")
            + "\n" + external.map(i => `\t"${i}"`).join("\n");

        return `import (\n${out.trim()})\n\n`;
    }
}

/**
 * A Func is a builder class to build function definitions in Go.
 */
export class Func implements Stringable {

    private args = new Array<Arg>();
    private returnsTypes = new Array<string>();
    private methodOfType: string;
    private body = new WriteCollector();

    constructor(private name: string) {}

    /**
     * Returns the name of the funciton.
     */
    getName(): string {
        return this.name;
    }

    /**
     * Adds a new argument to the function
     */
    arg(name: string, type: string): Arg {
        const a = new Arg(name, type);
        this.args.push(a);
        return a;
    }

    /**
     * addArgs appends a list of arguments to the function.
     */
    addArgs(...args: Array<Arg>): Func {
        this.args = this.args.concat(args);
        return this;
    }

    /**
     * Attempts to find and return an argument given its name. Returns
     * undefined if the argument is not attached to this function.
     */
    getArg(name: string): Arg {
        return this.args.find(a => a.argName === name);
    }

    /**
     * Sets this argument to be a method of some struct type.
     */
    methodOf(type: string): Func {
        this.methodOfType = type;
        return this;
    }

    /**
     * Appens a new return type to the function.
     */
    returns(type: string, name: string=null): Func {
        if (name) {
            type = `${name} ${type}`;
        }
        this.returnsTypes.push(type);
        return this;
    }

    /**
     * Appends data to the function body.
     */
    write(data: Stringable): Func {
        this.body.write(data);
        return this;
    }

    toString(): string {
        let out = "func ";
        if (this.methodOfType) {
            out += `(${this.methodOfType}) `;
        }
        out += `${this.name} (${this.args.map(a => a.toString()).join(", ")}) `;
        if (this.returnsTypes.length) {
            out += `(${this.returnsTypes.join(", ")}) `;
        }
        out += `{\n${this.body}\n}\n\n`;

        return out;
    }
}

/**
 * Call builds a Go function call.
 */
export class Call implements Stringable {

    public args = new Array<Arg>();

    constructor(public fn: string, ...args: Array<Arg>) {
        this.args = args;
    }

    /**
     * Adds a new argument to the call.
     */
    arg(name: string, type: string): Arg {
        return new Arg(name, type);
    }

    toString(): string {
        return `${this.fn}(${this.args.map(a => a.argName).join(", ")})\n`;
    }
}

/**
 * An Arg is an argument that is passed to a Func type.
 */
export class Arg implements Stringable {

    public variadic = false;

    constructor(public argName: string, public argType: string) {}

    toString(): string {
        return `${this.argName} ${this.variadic ? "..." : "" }${this.argType}`;
    }
}